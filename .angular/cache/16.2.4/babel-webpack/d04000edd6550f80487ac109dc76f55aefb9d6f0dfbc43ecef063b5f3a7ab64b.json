{"ast":null,"code":"import { HttpResponse } from '@angular/common/http';\nimport { finalize, tap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../message.service\";\nexport class LoggingInterceptor {\n  constructor(messenger) {\n    this.messenger = messenger;\n  }\n  intercept(req, next) {\n    const started = Date.now();\n    let ok;\n    // extend server response observable with logging\n    return next.handle(req).pipe(tap({\n      // Succeeds when there is a response; ignore other events\n      next: event => ok = event instanceof HttpResponse ? 'succeeded' : '',\n      // Operation failed; error is an HttpErrorResponse\n      error: error => ok = 'failed'\n    }),\n    // Log when response observable either completes or errors\n    finalize(() => {\n      const elapsed = Date.now() - started;\n      const msg = `${req.method} \"${req.urlWithParams}\"\n             ${ok} in ${elapsed} ms.`;\n      this.messenger.add(msg);\n    }));\n  }\n  static #_ = this.ɵfac = function LoggingInterceptor_Factory(t) {\n    return new (t || LoggingInterceptor)(i0.ɵɵinject(i1.MessageService));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: LoggingInterceptor,\n    factory: LoggingInterceptor.ɵfac\n  });\n}","map":{"version":3,"names":["HttpResponse","finalize","tap","LoggingInterceptor","constructor","messenger","intercept","req","next","started","Date","now","ok","handle","pipe","event","error","elapsed","msg","method","urlWithParams","add","_","i0","ɵɵinject","i1","MessageService","_2","factory","ɵfac"],"sources":["c:\\brettaio\\ng-http\\src\\app\\http-interceptors\\logging-interceptor.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport {\n  HttpEvent, HttpInterceptor, HttpHandler,\n  HttpRequest, HttpResponse\n} from '@angular/common/http';\n\nimport { finalize, tap } from 'rxjs/operators';\nimport { MessageService } from '../message.service';\n\n@Injectable()\nexport class LoggingInterceptor implements HttpInterceptor {\n  constructor(private messenger: MessageService) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler) {\n    const started = Date.now();\n    let ok: string;\n\n    // extend server response observable with logging\n    return next.handle(req)\n      .pipe(\n        tap({\n          // Succeeds when there is a response; ignore other events\n          next: (event) => (ok = event instanceof HttpResponse ? 'succeeded' : ''),\n          // Operation failed; error is an HttpErrorResponse\n          error: (error) => (ok = 'failed')\n        }),\n        // Log when response observable either completes or errors\n        finalize(() => {\n          const elapsed = Date.now() - started;\n          const msg = `${req.method} \"${req.urlWithParams}\"\n             ${ok} in ${elapsed} ms.`;\n          this.messenger.add(msg);\n        })\n      );\n  }\n}\n"],"mappings":"AACA,SAEeA,YAAY,QACpB,sBAAsB;AAE7B,SAASC,QAAQ,EAAEC,GAAG,QAAQ,gBAAgB;;;AAI9C,OAAM,MAAOC,kBAAkB;EAC7BC,YAAoBC,SAAyB;IAAzB,KAAAA,SAAS,GAATA,SAAS;EAAmB;EAEhDC,SAASA,CAACC,GAAqB,EAAEC,IAAiB;IAChD,MAAMC,OAAO,GAAGC,IAAI,CAACC,GAAG,EAAE;IAC1B,IAAIC,EAAU;IAEd;IACA,OAAOJ,IAAI,CAACK,MAAM,CAACN,GAAG,CAAC,CACpBO,IAAI,CACHZ,GAAG,CAAC;MACF;MACAM,IAAI,EAAGO,KAAK,IAAMH,EAAE,GAAGG,KAAK,YAAYf,YAAY,GAAG,WAAW,GAAG,EAAG;MACxE;MACAgB,KAAK,EAAGA,KAAK,IAAMJ,EAAE,GAAG;KACzB,CAAC;IACF;IACAX,QAAQ,CAAC,MAAK;MACZ,MAAMgB,OAAO,GAAGP,IAAI,CAACC,GAAG,EAAE,GAAGF,OAAO;MACpC,MAAMS,GAAG,GAAG,GAAGX,GAAG,CAACY,MAAM,KAAKZ,GAAG,CAACa,aAAa;eAC1CR,EAAE,OAAOK,OAAO,MAAM;MAC3B,IAAI,CAACZ,SAAS,CAACgB,GAAG,CAACH,GAAG,CAAC;IACzB,CAAC,CAAC,CACH;EACL;EAAC,QAAAI,CAAA,G;qBAxBUnB,kBAAkB,EAAAoB,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,cAAA;EAAA;EAAA,QAAAC,EAAA,G;WAAlBxB,kBAAkB;IAAAyB,OAAA,EAAlBzB,kBAAkB,CAAA0B;EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}