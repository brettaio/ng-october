{"ast":null,"code":"import { HttpEventType, HttpRequest } from '@angular/common/http';\nimport { of } from 'rxjs';\nimport { catchError, last, map, tap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"../message.service\";\nexport class UploaderService {\n  constructor(http, messenger) {\n    this.http = http;\n    this.messenger = messenger;\n  }\n  // If uploading multiple files, change to:\n  // upload(files: FileList) {\n  //   const formData = new FormData();\n  //   files.forEach(f => formData.append(f.name, f));\n  //   new HttpRequest('POST', '/upload/file', formData, {reportProgress: true});\n  //   ...\n  // }\n  upload(file) {\n    if (!file) {\n      return of();\n    }\n    // COULD HAVE WRITTEN:\n    // return this.http.post('/upload/file', file, {\n    //   reportProgress: true,\n    //   observe: 'events'\n    // }).pipe(\n    // Create the request object that POSTs the file to an upload endpoint.\n    // The `reportProgress` option tells HttpClient to listen and return\n    // XHR progress events.\n    const req = new HttpRequest('POST', '/upload/file', file, {\n      reportProgress: true\n    });\n    // The `HttpClient.request` API produces a raw event stream\n    // which includes start (sent), progress, and response events.\n    return this.http.request(req).pipe(map(event => this.getEventMessage(event, file)), tap(message => this.showProgress(message)), last(),\n    // return last (completed) message to caller\n    catchError(this.handleError(file)));\n  }\n  /** Return distinct message for sent, upload progress, & response events */\n  getEventMessage(event, file) {\n    switch (event.type) {\n      case HttpEventType.Sent:\n        return `Uploading file \"${file.name}\" of size ${file.size}.`;\n      case HttpEventType.UploadProgress:\n        // Compute and show the % done:\n        const percentDone = event.total ? Math.round(100 * event.loaded / event.total) : 0;\n        return `File \"${file.name}\" is ${percentDone}% uploaded.`;\n      case HttpEventType.Response:\n        return `File \"${file.name}\" was completely uploaded!`;\n      default:\n        return `File \"${file.name}\" surprising upload event: ${event.type}.`;\n    }\n  }\n  /**\r\n   * Returns a function that handles Http upload failures.\r\n   *\r\n   * @param file - File object for file being uploaded\r\n   *\r\n   * When no `UploadInterceptor` and no server,\r\n   * you'll end up here in the error handler.\r\n   */\n  handleError(file) {\n    const userMessage = `${file.name} upload failed.`;\n    return error => {\n      // TODO: send the error to remote logging infrastructure\n      console.error(error); // log to console instead\n      const message = error.error instanceof Error ? error.error.message : `server returned code ${error.status} with body \"${error.error}\"`;\n      this.messenger.add(`${userMessage} ${message}`);\n      // Let app keep running but indicate failure.\n      return of(userMessage);\n    };\n  }\n  showProgress(message) {\n    this.messenger.add(message);\n  }\n  static #_ = this.ɵfac = function UploaderService_Factory(t) {\n    return new (t || UploaderService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.MessageService));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: UploaderService,\n    factory: UploaderService.ɵfac\n  });\n}","map":{"version":3,"names":["HttpEventType","HttpRequest","of","catchError","last","map","tap","UploaderService","constructor","http","messenger","upload","file","req","reportProgress","request","pipe","event","getEventMessage","message","showProgress","handleError","type","Sent","name","size","UploadProgress","percentDone","total","Math","round","loaded","Response","userMessage","error","console","Error","status","add","_","i0","ɵɵinject","i1","HttpClient","i2","MessageService","_2","factory","ɵfac"],"sources":["c:\\brettaio\\ng-http\\src\\app\\uploader\\uploader.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport {\n  HttpClient, HttpEvent, HttpEventType, HttpProgressEvent,\n  HttpRequest, HttpResponse, HttpErrorResponse\n} from '@angular/common/http';\n\nimport { of } from 'rxjs';\nimport { catchError, last, map, tap } from 'rxjs/operators';\n\nimport { MessageService } from '../message.service';\n\n@Injectable()\nexport class UploaderService {\n  constructor(\n    private http: HttpClient,\n    private messenger: MessageService) {}\n\n  // If uploading multiple files, change to:\n  // upload(files: FileList) {\n  //   const formData = new FormData();\n  //   files.forEach(f => formData.append(f.name, f));\n  //   new HttpRequest('POST', '/upload/file', formData, {reportProgress: true});\n  //   ...\n  // }\n\n  upload(file: File) {\n    if (!file) { return of<string>(); }\n\n    // COULD HAVE WRITTEN:\n    // return this.http.post('/upload/file', file, {\n    //   reportProgress: true,\n    //   observe: 'events'\n    // }).pipe(\n\n    // Create the request object that POSTs the file to an upload endpoint.\n    // The `reportProgress` option tells HttpClient to listen and return\n    // XHR progress events.\n    const req = new HttpRequest('POST', '/upload/file', file, {\n      reportProgress: true\n    });\n\n    // The `HttpClient.request` API produces a raw event stream\n    // which includes start (sent), progress, and response events.\n    return this.http.request(req).pipe(\n      map(event => this.getEventMessage(event, file)),\n      tap(message => this.showProgress(message)),\n      last(), // return last (completed) message to caller\n      catchError(this.handleError(file))\n    );\n  }\n\n  /** Return distinct message for sent, upload progress, & response events */\n  private getEventMessage(event: HttpEvent<any>, file: File) {\n    switch (event.type) {\n      case HttpEventType.Sent:\n        return `Uploading file \"${file.name}\" of size ${file.size}.`;\n\n      case HttpEventType.UploadProgress:\n        // Compute and show the % done:\n        const percentDone = event.total ? Math.round(100 * event.loaded / event.total) : 0;\n        return `File \"${file.name}\" is ${percentDone}% uploaded.`;\n\n      case HttpEventType.Response:\n        return `File \"${file.name}\" was completely uploaded!`;\n\n      default:\n        return `File \"${file.name}\" surprising upload event: ${event.type}.`;\n    }\n  }\n\n  /**\n   * Returns a function that handles Http upload failures.\n   *\n   * @param file - File object for file being uploaded\n   *\n   * When no `UploadInterceptor` and no server,\n   * you'll end up here in the error handler.\n   */\n  private handleError(file: File) {\n    const userMessage = `${file.name} upload failed.`;\n\n    return (error: HttpErrorResponse) => {\n      // TODO: send the error to remote logging infrastructure\n      console.error(error); // log to console instead\n\n      const message = (error.error instanceof Error) ?\n        error.error.message :\n       `server returned code ${error.status} with body \"${error.error}\"`;\n\n      this.messenger.add(`${userMessage} ${message}`);\n\n      // Let app keep running but indicate failure.\n      return of(userMessage);\n    };\n  }\n\n  private showProgress(message: string) {\n    this.messenger.add(message);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}