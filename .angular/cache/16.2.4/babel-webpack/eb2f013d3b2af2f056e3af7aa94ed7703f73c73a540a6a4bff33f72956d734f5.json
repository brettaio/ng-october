{"ast":null,"code":"import { HttpResponse, HttpEventType } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport * as i0 from \"@angular/core\";\n/** Simulate server replying to file upload request */\nexport class UploadInterceptor {\n  intercept(req, next) {\n    if (req.url.indexOf('/upload/file') === -1) {\n      return next.handle(req);\n    }\n    const delay = 300; // TODO: inject delay?\n    return createUploadEvents(delay);\n  }\n  static #_ = this.ɵfac = function UploadInterceptor_Factory(t) {\n    return new (t || UploadInterceptor)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: UploadInterceptor,\n    factory: UploadInterceptor.ɵfac\n  });\n}\n/** Create simulation of upload event stream */\nfunction createUploadEvents(delay) {\n  // Simulate XHR behavior which would provide this information in a ProgressEvent\n  const chunks = 5;\n  const total = 12345678;\n  const chunkSize = Math.ceil(total / chunks);\n  return new Observable(observer => {\n    // notify the event stream that the request was sent.\n    observer.next({\n      type: HttpEventType.Sent\n    });\n    uploadLoop(0);\n    function uploadLoop(loaded) {\n      // N.B.: Cannot use setInterval or rxjs delay (which uses setInterval)\n      // because e2e test won't complete. A zone thing?\n      // Use setTimeout and tail recursion instead.\n      setTimeout(() => {\n        loaded += chunkSize;\n        if (loaded >= total) {\n          const doneResponse = new HttpResponse({\n            status: 201 // OK but no body;\n          });\n\n          observer.next(doneResponse);\n          observer.complete();\n          return;\n        }\n        const progressEvent = {\n          type: HttpEventType.UploadProgress,\n          loaded,\n          total\n        };\n        observer.next(progressEvent);\n        uploadLoop(loaded);\n      }, delay);\n    }\n  });\n}","map":{"version":3,"names":["HttpResponse","HttpEventType","Observable","UploadInterceptor","intercept","req","next","url","indexOf","handle","delay","createUploadEvents","_","_2","factory","ɵfac","chunks","total","chunkSize","Math","ceil","observer","type","Sent","uploadLoop","loaded","setTimeout","doneResponse","status","complete","progressEvent","UploadProgress"],"sources":["c:\\brettaio\\ng-http\\src\\app\\http-interceptors\\upload-interceptor.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport {\n  HttpEvent, HttpInterceptor, HttpHandler,\n  HttpRequest, HttpResponse,\n  HttpEventType, HttpProgressEvent\n} from '@angular/common/http';\n\nimport { Observable } from 'rxjs';\n\n/** Simulate server replying to file upload request */\n@Injectable()\nexport class UploadInterceptor implements HttpInterceptor {\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (req.url.indexOf('/upload/file') === -1) {\n      return next.handle(req);\n    }\n    const delay = 300; // TODO: inject delay?\n    return createUploadEvents(delay);\n  }\n}\n\n/** Create simulation of upload event stream */\nfunction createUploadEvents(delay: number) {\n  // Simulate XHR behavior which would provide this information in a ProgressEvent\n  const chunks = 5;\n  const total = 12345678;\n  const chunkSize = Math.ceil(total / chunks);\n\n  return new Observable<HttpEvent<any>>(observer => {\n    // notify the event stream that the request was sent.\n    observer.next({type: HttpEventType.Sent});\n\n    uploadLoop(0);\n\n    function uploadLoop(loaded: number) {\n      // N.B.: Cannot use setInterval or rxjs delay (which uses setInterval)\n      // because e2e test won't complete. A zone thing?\n      // Use setTimeout and tail recursion instead.\n        setTimeout(() => {\n          loaded += chunkSize;\n\n          if (loaded >= total) {\n            const doneResponse = new HttpResponse({\n              status: 201, // OK but no body;\n            });\n            observer.next(doneResponse);\n            observer.complete();\n            return;\n          }\n\n          const progressEvent: HttpProgressEvent = {\n            type: HttpEventType.UploadProgress,\n            loaded,\n            total\n          };\n          observer.next(progressEvent);\n          uploadLoop(loaded);\n        }, delay);\n    }\n  });\n}\n"],"mappings":"AACA,SAEeA,YAAY,EACzBC,aAAa,QACR,sBAAsB;AAE7B,SAASC,UAAU,QAAQ,MAAM;;AAEjC;AAEA,OAAM,MAAOC,iBAAiB;EAC5BC,SAASA,CAACC,GAAqB,EAAEC,IAAiB;IAChD,IAAID,GAAG,CAACE,GAAG,CAACC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,EAAE;MAC1C,OAAOF,IAAI,CAACG,MAAM,CAACJ,GAAG,CAAC;;IAEzB,MAAMK,KAAK,GAAG,GAAG,CAAC,CAAC;IACnB,OAAOC,kBAAkB,CAACD,KAAK,CAAC;EAClC;EAAC,QAAAE,CAAA,G;qBAPUT,iBAAiB;EAAA;EAAA,QAAAU,EAAA,G;WAAjBV,iBAAiB;IAAAW,OAAA,EAAjBX,iBAAiB,CAAAY;EAAA;;AAU9B;AACA,SAASJ,kBAAkBA,CAACD,KAAa;EACvC;EACA,MAAMM,MAAM,GAAG,CAAC;EAChB,MAAMC,KAAK,GAAG,QAAQ;EACtB,MAAMC,SAAS,GAAGC,IAAI,CAACC,IAAI,CAACH,KAAK,GAAGD,MAAM,CAAC;EAE3C,OAAO,IAAId,UAAU,CAAiBmB,QAAQ,IAAG;IAC/C;IACAA,QAAQ,CAACf,IAAI,CAAC;MAACgB,IAAI,EAAErB,aAAa,CAACsB;IAAI,CAAC,CAAC;IAEzCC,UAAU,CAAC,CAAC,CAAC;IAEb,SAASA,UAAUA,CAACC,MAAc;MAChC;MACA;MACA;MACEC,UAAU,CAAC,MAAK;QACdD,MAAM,IAAIP,SAAS;QAEnB,IAAIO,MAAM,IAAIR,KAAK,EAAE;UACnB,MAAMU,YAAY,GAAG,IAAI3B,YAAY,CAAC;YACpC4B,MAAM,EAAE,GAAG,CAAE;WACd,CAAC;;UACFP,QAAQ,CAACf,IAAI,CAACqB,YAAY,CAAC;UAC3BN,QAAQ,CAACQ,QAAQ,EAAE;UACnB;;QAGF,MAAMC,aAAa,GAAsB;UACvCR,IAAI,EAAErB,aAAa,CAAC8B,cAAc;UAClCN,MAAM;UACNR;SACD;QACDI,QAAQ,CAACf,IAAI,CAACwB,aAAa,CAAC;QAC5BN,UAAU,CAACC,MAAM,CAAC;MACpB,CAAC,EAAEf,KAAK,CAAC;IACb;EACF,CAAC,CAAC;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}