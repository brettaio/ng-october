{"ast":null,"code":"import { HttpResponse } from '@angular/common/http';\nimport { of } from 'rxjs';\nimport { startWith, tap } from 'rxjs/operators';\nimport { searchUrl } from '../package-search/package-search.service';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../request-cache.service\";\n/**\r\n * If request is cacheable (e.g., package search) and\r\n * response is in cache return the cached response as observable.\r\n * If has 'x-refresh' header that is true,\r\n * then also re-run the package search, using response from next(),\r\n * returning an observable that emits the cached response first.\r\n *\r\n * If not in cache or not cacheable,\r\n * pass request through to next()\r\n */\nexport class CachingInterceptor {\n  constructor(cache) {\n    this.cache = cache;\n  }\n  intercept(req, next) {\n    // continue if not cacheable.\n    if (!isCacheable(req)) {\n      return next.handle(req);\n    }\n    const cachedResponse = this.cache.get(req);\n    // cache-then-refresh\n    if (req.headers.get('x-refresh')) {\n      const results$ = sendRequest(req, next, this.cache);\n      return cachedResponse ? results$.pipe(startWith(cachedResponse)) : results$;\n    }\n    // cache-or-fetch\n    return cachedResponse ? of(cachedResponse) : sendRequest(req, next, this.cache);\n  }\n  static #_ = this.ɵfac = function CachingInterceptor_Factory(t) {\n    return new (t || CachingInterceptor)(i0.ɵɵinject(i1.RequestCache));\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: CachingInterceptor,\n    factory: CachingInterceptor.ɵfac\n  });\n}\n/** Is this request cacheable? */\nfunction isCacheable(req) {\n  // Only GET requests are cacheable\n  return req.method === 'GET' &&\n  // Only npm package search is cacheable in this app\n  -1 < req.url.indexOf(searchUrl);\n}\n/**\r\n * Get server response observable by sending request to `next()`.\r\n * Will add the response to the cache on the way out.\r\n */\nfunction sendRequest(req, next, cache) {\n  return next.handle(req).pipe(tap(event => {\n    // There may be other events besides the response.\n    if (event instanceof HttpResponse) {\n      cache.put(req, event); // Update the cache.\n    }\n  }));\n}","map":{"version":3,"names":["HttpResponse","of","startWith","tap","searchUrl","CachingInterceptor","constructor","cache","intercept","req","next","isCacheable","handle","cachedResponse","get","headers","results$","sendRequest","pipe","_","i0","ɵɵinject","i1","RequestCache","_2","factory","ɵfac","method","url","indexOf","event","put"],"sources":["c:\\brettaio\\ng-http\\src\\app\\http-interceptors\\caching-interceptor.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport {\n  HttpEvent, HttpHeaders, HttpRequest, HttpResponse,\n  HttpInterceptor, HttpHandler\n} from '@angular/common/http';\n\nimport { Observable, of } from 'rxjs';\nimport { startWith, tap } from 'rxjs/operators';\n\nimport { RequestCache } from '../request-cache.service';\nimport { searchUrl } from '../package-search/package-search.service';\n\n\n/**\n * If request is cacheable (e.g., package search) and\n * response is in cache return the cached response as observable.\n * If has 'x-refresh' header that is true,\n * then also re-run the package search, using response from next(),\n * returning an observable that emits the cached response first.\n *\n * If not in cache or not cacheable,\n * pass request through to next()\n */\n@Injectable()\nexport class CachingInterceptor implements HttpInterceptor {\n  constructor(private cache: RequestCache) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler) {\n    // continue if not cacheable.\n    if (!isCacheable(req)) { return next.handle(req); }\n\n    const cachedResponse = this.cache.get(req);\n    // cache-then-refresh\n    if (req.headers.get('x-refresh')) {\n      const results$ = sendRequest(req, next, this.cache);\n      return cachedResponse ?\n        results$.pipe( startWith(cachedResponse) ) :\n        results$;\n    }\n    // cache-or-fetch\n    return cachedResponse ?\n      of(cachedResponse) : sendRequest(req, next, this.cache);\n  }\n}\n\n\n/** Is this request cacheable? */\nfunction isCacheable(req: HttpRequest<any>) {\n  // Only GET requests are cacheable\n  return req.method === 'GET' &&\n    // Only npm package search is cacheable in this app\n    -1 < req.url.indexOf(searchUrl);\n}\n\n/**\n * Get server response observable by sending request to `next()`.\n * Will add the response to the cache on the way out.\n */\nfunction sendRequest(\n  req: HttpRequest<any>,\n  next: HttpHandler,\n  cache: RequestCache): Observable<HttpEvent<any>> {\n  return next.handle(req).pipe(\n    tap(event => {\n      // There may be other events besides the response.\n      if (event instanceof HttpResponse) {\n        cache.put(req, event); // Update the cache.\n      }\n    })\n  );\n}\n\n"],"mappings":"AACA,SACuCA,YAAY,QAE5C,sBAAsB;AAE7B,SAAqBC,EAAE,QAAQ,MAAM;AACrC,SAASC,SAAS,EAAEC,GAAG,QAAQ,gBAAgB;AAG/C,SAASC,SAAS,QAAQ,0CAA0C;;;AAGpE;;;;;;;;;;AAWA,OAAM,MAAOC,kBAAkB;EAC7BC,YAAoBC,KAAmB;IAAnB,KAAAA,KAAK,GAALA,KAAK;EAAiB;EAE1CC,SAASA,CAACC,GAAqB,EAAEC,IAAiB;IAChD;IACA,IAAI,CAACC,WAAW,CAACF,GAAG,CAAC,EAAE;MAAE,OAAOC,IAAI,CAACE,MAAM,CAACH,GAAG,CAAC;;IAEhD,MAAMI,cAAc,GAAG,IAAI,CAACN,KAAK,CAACO,GAAG,CAACL,GAAG,CAAC;IAC1C;IACA,IAAIA,GAAG,CAACM,OAAO,CAACD,GAAG,CAAC,WAAW,CAAC,EAAE;MAChC,MAAME,QAAQ,GAAGC,WAAW,CAACR,GAAG,EAAEC,IAAI,EAAE,IAAI,CAACH,KAAK,CAAC;MACnD,OAAOM,cAAc,GACnBG,QAAQ,CAACE,IAAI,CAAEhB,SAAS,CAACW,cAAc,CAAC,CAAE,GAC1CG,QAAQ;;IAEZ;IACA,OAAOH,cAAc,GACnBZ,EAAE,CAACY,cAAc,CAAC,GAAGI,WAAW,CAACR,GAAG,EAAEC,IAAI,EAAE,IAAI,CAACH,KAAK,CAAC;EAC3D;EAAC,QAAAY,CAAA,G;qBAlBUd,kBAAkB,EAAAe,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,YAAA;EAAA;EAAA,QAAAC,EAAA,G;WAAlBnB,kBAAkB;IAAAoB,OAAA,EAAlBpB,kBAAkB,CAAAqB;EAAA;;AAsB/B;AACA,SAASf,WAAWA,CAACF,GAAqB;EACxC;EACA,OAAOA,GAAG,CAACkB,MAAM,KAAK,KAAK;EACzB;EACA,CAAC,CAAC,GAAGlB,GAAG,CAACmB,GAAG,CAACC,OAAO,CAACzB,SAAS,CAAC;AACnC;AAEA;;;;AAIA,SAASa,WAAWA,CAClBR,GAAqB,EACrBC,IAAiB,EACjBH,KAAmB;EACnB,OAAOG,IAAI,CAACE,MAAM,CAACH,GAAG,CAAC,CAACS,IAAI,CAC1Bf,GAAG,CAAC2B,KAAK,IAAG;IACV;IACA,IAAIA,KAAK,YAAY9B,YAAY,EAAE;MACjCO,KAAK,CAACwB,GAAG,CAACtB,GAAG,EAAEqB,KAAK,CAAC,CAAC,CAAC;;EAE3B,CAAC,CAAC,CACH;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}